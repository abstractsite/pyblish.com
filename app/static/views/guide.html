<link rel="stylesheet" href="static/css/markdown.css">


<section>

<pb-headline
  title="Guide">
    Welcome to the <a href="https://github.com/abstractfactory/pyblish">Pyblish</a> Guide. If you should find that anything is amiss and would like to contribute, feel free to <a href="https://github.com/pyblish/pyblish.github.io">fork this repository</a> and submit a pull-request.
</pb-headline>

<pb-markdown>


# What Is Publishing

> Funnel the output of individual artists so as to streamline retrieval, automation and understanding of an otherwise overwhelming amount of data.

Publishing is what Pyblish is all about. But what exactly is "publishing"?

![](static/img/guide/what-is-publishing4_before.png)

The concept may originally have descended from from software development, in which the term *testing* refers to..

> ..the process of validating and verifying that a software program or application or product meets the business and technical requirements that guided it's design and development. - [Reference][testing_ref]

In the illustration above, no testing or validation takes place, thus leaving your assets vulnerable to error. Each error then trickles through your pipeline, from artist to artist, until it will eventually have to be sent back from whence it came. Sound familiar?

![](static/img/guide/what-is-publishing4_after.png)

With publishing, errors can be caught *before* they get a chance to infect any part of your pipeline. The end result is happier developers, happier artists and happier clients.

### References

- [Types of testing][testing]
- [What is software testing][testing2]

[testing2]: http://istqbexamcertification.com/what-is-a-software-testing/
[testing]: http://www.softwaretestinghelp.com/types-of-software-testing/
[testing_ref]: http://istqbexamcertification.com/what-is-a-software-testing/



# How It Works

Being a plug-in driven framework means that everything it does is done by plug-ins and that the surrounding library merely finds and triggers them at the opportune time. Let's have a look at how it does this.

Plug-ins are categorised by four distinct processes.

1. Selection
2. Validation
3. Extraction
4. Conform

Each process runs one after another, in this exact order.

### Selection

> The Magnet

Selection is the process of gathering information about the content you wish to publish. This information may be things such as the currently logged on user, the time of day and, perhaps most importantly, which part of a working file you are interested in sharing with others. You can think of it as a magnet.

For example, if your working file contains a `Cube`, `Sphere` and `Torus`, you may wish to see the `Sphere` published. Each publishable element within your scene is called an `Instance`. An instance is an *instantiation* of content. That is, once a file is loaded into a program, the file has become an instance.

In this case, our `Cube`, `Sphere` and `Torus` are all instances. These instances are then collected into a `Context`. The context is singular throughout the lifespan of a single publish and represents all knowledge Pyblish has about your workspace.

### Validation

> The Gatekeeper

Validation is the step perhaps most associated with publishing. These plug-ins look at the information collected from Selection and *validates* it. A validation may be something like:

```
"Make sure all names end with a three-letter extension"
```

Validators are the gatekeepers of content.

### Extraction

> The Rock Carver

Once finished, the context will be passed on to Extraction. Extraction has one responsbility - get whatever has been collected during Selection and *extract* it from your application, typically onto disk. You can think of *this* as rock carving; persisting temporal data onto disk.

However, Extraction can only occur if validation was successful. This is one of the key tenets of publishing. We only want data extracted if it lives up to the criteria set forth by your organisation. Luckily for us, our `Sphere` was called "MySphere_GEO" and is therefore valid.

Once our `Sphere` resides on disk, it is time for the final step of publishing.

### Conform

> The Transporter

Conform is the process of integrating the extracted content into the rest of your pipeline. This includes placing the files where you typically store this kind of data, spheres in this case, and possibly register the event with a central database, such as an online task tracking solution. This step is synonymous to shipping or transportation.

## How Integrations Work

Now that we know a little bit about the process and how plug-ins work, let's talk about the integrations.

As content is generated by artists in a variety of software, it is imperative that Pyblish can be there to validate it. That is why only the most rudimentary of features ship with the base library of Pyblish, and more in-depth features come in any of its integrations.

![](static/img/guide/maya-pyblish.png)

For example, the Autodesk Maya integration comes with a few demo plug-ins to help users of Maya get started in writing their own plug-ins along with a method in which they can publish their content directly from within Maya.

![](static/img/guide/asana-pyblish.png)

Other integrations, such as Asana, are software-neutral and offer users the option of communicating their publishing efforts into a cloud-based task tracking solution.

![](static/img/guide/openmetadata-pyblish.png)

Another software-neutral integration is one for Open Metadata, with which users are given the option to persist additional data to their publishes, such as who did what and when along arbitrary metadata useful in further automation of the output.

All of these integrations however operate under the same premise that all features are hosted within plug-ins and that you are free to either use, modify or extend them to fit your unique circumstances.




# Installation

The best way to learn anything is to try things out.

    # Pyblish is available via pip
    $ pip install pyblish

To test things out, let's try and import our newly installed package.


    >>> import pyblish
    >>> pyblish.version
    '1.0.11'


> If this isn't the results you've got, head on over to [Troubleshooting](#troubleshooting) and we'll try and get things sorted.

The next few sections cover some in-depth details about Pyblish, but if you'd rather get your feet wet with publishing within Autodesk Maya, head on down to [Publishing](#publishing---with-autodesk-maya) to get started!


# Configuring Pyblish

Besides being completely driven by plug-in, Pyblish also provides options to be configured further. Primarily in the form of exposing the various plug-ins to your various circumstances. You can do that, let's find out how.

- [Custom paths](#custom-paths)
- [User Configuration](#user-configuration)
- [Visualising Paths](#visualising-paths)

## Custom paths

The most important aspect of configuration is how you expose your plugins to your pipeline. Paths have three levels of configuration, each with its own benefits and disadvantages.

- [Via Python](#custom-paths-via-python)
- [Via configuration](#custom-paths-via-configuration)
- [Via environment](#custom-paths-via-environment)

#### Custom paths via python

Exposing plug-ins via Python is known as *registering paths* and can be done like this:


    >>> import pyblish.plugin
    >>> pyblish.plugin.register_plugin_path(r'c:\my_path')


You can manipulate the paths further with the following functions:


    >>> pyblish.plugin.deregister_plugin_path(r'c:\my_path')
    >>> pyblish.plugin.deregister_all()


To inspect which paths are currently registered, you can use this:


    >>> pyblish.plugin.registered_paths
    ['c:\my_path']


#### Custom paths via environment

You may also inject plug-in paths directly into your environment. These will get picked up by Pyblish at run-time and augment any pre-existing paths already exposed via Python or configuration.

This is particularly helpful if you launch processes via a [wrapper][], which you can configure to append plugins relevant to your particular project.


    import os
    import subprocess

    custom_environment = os.environ.copy()
    custom_environment['PYBLISHPLUGINPATH'] = "c:\spiderman_plugins"

    subprocess.Popen('maya', env=custom_environment)


[wrapper]: https://github.com/abstractfactory/pyblish/wiki/Glossary#wrapperbootstrapper

#### Custom paths via configuration

But how do you actually add paths via configuration? If you head into the Python package, typically located here:


    c:\Python27\Lib\site-packages\pyblish


And look for a `config.yaml`. This file contains everything that can be configured about the internals of Pyblish, including plugin paths.

**config.yaml**


    paths: 
        - "{pyblish}/plugins"


In this YAML-formatted file you can see a rather odd looking path. This is the default plug-in path for Pyblish and points to an inner directory of the Python library called `plugins`. The curly-braces represents string-substitution; at run-time, this is replaced with the actual path to the Pyblish Python library.

- For a full view of this file, [see here][config].

# User Configuration

The user configuration is a special YAML file located within your HOME directory.


    # On Windows, it may be located at
    c:\users\marcus\.pyblish


### Creating a User Configuration

To create your own configuration file:

1. Locate your HOME directory
2. Create an empty file
3. Name it `.pyblish`, with a leading dot.

> On Windows, naming files this way can be quite the hassle. Here's a hint; try naming the file with a dot at the end - `.pyblish.`

### Using Your User Configuration

A user configuration augments the existing configuration.

You can think of it like a Python dictionary.


    >>> my_config = {'name': 'Marcus', 'favourite_color': 'Blue'}


Dictionaries have an `update()` method which adds missing and replaces existing variables with another dictionary.


    >>> my_config.update({'favourite_color': 'Red'})
    >>> my_config
    {'name': 'Marcus', 'favourite_color': 'Red'}


As you can see, existing variables were left alone, but my favourite color is now red! This is much like your user configuration works. Anything you add to this file will either add to, or overwrite the default configuration for Pyblish.

### User Configuration And Paths

Ok, so you now know where paths are being configured, but it's best to avoid tampering with files within an actual library; you would then run the risk of losing your work if the library were to be reinstalled or updated.

A better way is to augment this configuration with your own. This is where the user configuration can really show its true colors.

**.pyblish**


    paths:
        - "c:/my_configured_path"


By creating a user configuration and *overriding* the `paths` variable, we've stripped Pyblish of it's default path for plugins.

> WARNING: Be careful if choosing not to include the default path as some plugins may depend on what they do; such as appending the current working directory to your context at run-time.

To ensure Pyblish still has access to its plugins, copy its path from the default configuration.

**.pyblish**


    paths:
        - "{pyblish}/plugins"
        - "c:/my_configured_path"


# Visualising Paths

To inspect *all* paths exposed to Pyblish, including those added via PYBLISHPLUGINPATH and configuration, you can use this:


    >>> pyblish.plugin.plugin_paths()
    ['c:\Python27\Lib\site-packages\pyblish\plugins', 'c:\my_configured_path', 'c:\my_environment_path']


This is can be great for debugging if you ever get lost in the midst of paths. You can also inspect configured paths individually:


    >>> import pyblish.config
    >>> pyblish.config.paths
    ['{pyblish}/plugins', 'c:\my_configured_path']


> You'll note that the default path hasn't yet been expanded. This is due to `plugin.config` being a direct representation of the configuration file(s). No processing has yet taken place at this point.

Along with those added via the environment


    >>> import os
    >>> os.environ['PYBLISHPLUGINPATH']
    'c:\my_environment_path'


##### Configuration and its location

User-configuration defaults to your home-directory. With this, it is possible to maintain an overarching configuration on a shared drive that sym-links into each users home-directory.

- See [symlinking][] for more information.

However it may be beneficial to provide an option for where Pyblish looks for its configuration. Feel free to drop us a line (or a pull-request) with any ideas.

[symlinking]: http://www.howtogeek.com/howto/16226/complete-guide-to-symbolic-links-symlinks-on-windows-or-linux/
[config]: https://github.com/abstractfactory/pyblish/blob/master/pyblish/config.yaml





# Mocking With Pyblish

When working on plugins for Pyblish, it can sometimes be helpful to put aside heavy dependencies of host applications such as Autodesk Maya or SideFx Houdini and instead work a little closer to the metal of what makes Pyblish tick.

For these circumstances, here is some information about how you can mock the various components so as to bypass or augment the publishing process, or to isolate your plugin from external stimuli.

I'll be presenting some source code below, you can either copy paste it as we go along, or you can head on over to the source code for all examples bundled into one complete example.

- [Mocking instances](#mocking-instances)
- [Mocking plugins](#mocking-plugins)
- [A mocking conclusion](#A-mocking-conclusion)
- [Nail on the head](#nail-on-the-head)
- [**Source code**][full]


### Mocking Instances


An instance is a collection of data that is on its way to become one or more files on disk. The context contains one or more instances, and as plugins only deal with contexts, we'll need it to make an instance:


    import pyblish.plugin

    context = pyblish.plugin.Context()
    instance = context.create_instance(name='MyInstance')


The next step is to add a family, so that compatible plugins can operate on it.


    instance.set_data('family', value='my_family')


And that's it. We can now publish this instance.


    for type in ('selectors', 'validators', 'extractors', 'conforms'):
        for plugin in pyblish.plugin.discover(type):
            plugin().process_all(context)


This will take it through the stages of being published. But of course, we have no plugins compatible with the family `my_family`. So we'll need to make some.

### Mocking Plugins

A plugin is a subclass of `Plugin` which has a subclass for each type of plugin. So let's start with that.


    class ValidateMyInstance(pyblish.plugin.Validator):
         family = ['my_family']
         host = ['maya']

         def process_instance(self, instance):
             assert instance.data('family') == 'my_family'


This plugin is now compatible with our instance. And as we're in the midst of mocking, let's not bother saving this out to a file. Instead, we'll use it directly.


    for type in ('selectors', 'validators', 'extractors', 'conforms'):
        for plugin in pyblish.plugin.discover(type):
            plugin().process_all(context)
     
        if type == 'validators':
            # Run our mocked up plugin once validators kick in
            ValidateMyInstance().process_all(context)


## A Mocking Conclusion

And so the story goes. Now we can easily make instances on our own behalf, instead of having Selectors create them for us. We can create our own plugins on-the-fly, without bothering with paths or discovery.

With this in mind, we should be able to make a fully-featured UI. A UI that displays what instances we've created, and what plugins are about to be processing them.

### Nail On The Head

Since publishing typically is associated with actually writing something to disk, as a final example, let's mock a plugin that does this.


    instance.set_data('document_content', 'Hello World!')
    instance.set_data('document_name', 'MyDocument.txt')


As you'll see, this isn't your typical Maya instance with nodes being exported. This is a plain file writer, storing a very important message on disk.

Now we need our extractor.


    import os

    class ExtractDocument(pyblish.plugin.Extractor):
        families = ['my_family']
        hosts = ['*']

        def process_instance(self, instance):
            content = instance.data('document_content')
            name = instance.data('document_name')

            # Since we aren't in Maya or anything, let's use the Current
            # Working Directory as parent to our document.
            parent_dir = instance.context.data('cwd')

            # The current working directory is being added to the context by
            # one of the included selector plugins. Now let's write the
            # document to disk.
            path = os.path.join(parent_dir, name)
            with open(path, 'w') as f:
                print "Writing message to %s" % path
                f.write(content)


And that's it. This extractor will keep overwriting the same file over and over, each time it is run, and it will save the file right next to wherever you first launched the script from.

Full example [here][full].

[full]: https://gist.github.com/mottosso/124d376c46853a574c0a





# Publishing - With Autodesk Maya

> The following sections are instructions on how to get Pyblish up and running using Autodesk Maya.


If you haven't already installed Pyblish, head back up to the [installation guide][Pyblish] to get started. Once ready, run this.


    # Pyblish for Maya is a regular Python package on PyPI
    $ pip install pyblish-maya


> Pyblish is being tested using versions 2013, 2014 and 2015

[Pyblish]: #installation

### Installing the Integration Into Maya

The next step is to expose the integration to Maya. For this, you've got two options.

1. Append a `userSetup.py` to your PYTHONPATH

    
        # Typically, the integration is located here
        c:\Python27\Lib\site-packages\pyblish_maya\pythonpath
    

    Append this path to your `PYTHONPATH`. See here for [help with modifying your environment][var]

2. Append to your own `userSetup.py`

    
        # Typically located here:
        C:\Users\marcus\Documents\maya\scripts\userSetup.py
        

     Append the following

        import pyblish_maya.lib
        pyblish_maya.lib.register_plugins()
        pyblish_maya.lib.add_to_filemenu()


[var]: https://github.com/abstractfactory/pyblish/wiki/Adding-an-environment-variable

### Testing Things Out

The next time you open up Maya, look for an item in your `File` menu that reads "Publish". If you haven't got it, head over to the [Troubleshooting](#troubleshooting) section and we'll get you sorted out.


# Making Your First Publish

> This guide assumes you've got a freshly installed version of Maya and that you haven't changed it's project directory.

By the end of this page, sir, *you* will have made your first publish. Just follow these steps one by one and we'll take you through how to make it happen.

**Table of contents**

- Create something
- Select it
- Make it publishable
- Dissection
 - Where did the publish go?
 - How it works
 - 5 minutes later
 - Why did it go there?
 - Where did the naming convention come from?
- Conclusion

### Create something

How about a cube.

1. In your `Create` menu
2. Click `Polygon Primitives`
3. Click `Cube`
4. Rename your cube to "myCube"

Or type the following in your script editor.


    from maya import cmds
    cmds.polyCube(name='myCube')


### Publish

Allright, let's try publishing.

1. In your `File` menu
2. Click `Publish`

Or type the following:


    import pyblish.main
    pyblish.main.publish()


Hmm. You're cube should have been published by now, but instead you've got a message saying:


    # No instances found. # 


What is that all about? As it turns out, there are just a few more steps we'll need to take before the button will know of exactly what and how you would like to perform your publish.

### Select it

*Select* is an important keyword in Pyblish. To *Select*, in Pyblish, means to specify what you would like to have published.

To select your cube, add it to a selection set.

1. In your `Create` menu
2. Click `Sets`
3. Followed by `Set`
4. Rename your set to "MyCube"

Or, type the following:


    cmds.sets(name='MyCube')


If you didn't have `myCube` selected when you created the set, make sure to add it to the set, either by dragging-and-dropping or by typing:


    cmds.sets('myCube', addElement='MyCube')


### Publish

Allright, let's try that again.

1. In your `File` menu
2. Click `Publish`

Or type the following:


    import pyblish.main
    pyblish.main.publish()


Hmm, we're still missing something.


    # No instances found. # 


### Make it publishable

For Pyblish to know that *this* is what you would like to Publish, and nothing else, we need to tag the selection set. To tag it, add the following attributes and values.


    publishable (bool): True
    family (string): "demo.model"


You can add it by going to your [Channel Box][chan].

1. In your `Edit` menu
2. Click `Add Attribute`
3. Type `publishable` as `Long name`
4. Click `Boolean` as `Data Type`
5. Hit `Add`
6. Type `family` as `Long name`
7. Click `String` as `Data Type`
8. Hit `OK`

Or type the following:


    cmds.addAttr('MyCube', at='bool', longName='publishable')
    cmds.addAttr('MyCube', dt='string', longName='family')


Next, fill in the values.

1. In your [Attribute Editor][attributeeditor]
2. Under `Extra Attributes`
3. Toggle `publishable` to True
4. Type `demo.model` in the `family` text box

Or type the following:


    cmds.setAttr('MyCube.publishable', True)
    cmds.setAttr('MyCube.family', 'demo.model', type='string')


Now Pyblish will be able to distinguish between this set and any other set you might have.

### Publish

Third time's the charm, right?

1. In your `File` menu
2. Click `Publish`

Or type the following:


    import pyblish.main
    pyblish.main.publish()


**Error!**


    # Error:
    # ValueError: The following nodes were misnamed
    #   myCube


Uh-oh. Looks like we've got a new error this time. By the looks of it, our Cube wasn't named according to the naming conventions. Let's try and remedy this. Currently, the naming convention is for everything you publish to always have a three-letter extension.

1. Rename `myCube` to `myCube_GEO`
2. Re-run the publish

You should now see this message in your script editor.


    # Finished successfully #


[chan]: http://download.autodesk.com/global/docs/maya2014/en_us/files/GUID-424694BA-019A-4D05-86EF-F9CD0A69D92C.htm
[attributeeditor]: http://download.autodesk.com/global/docs/maya2014/en_us/files/GUID-67A58D31-4722-4769-B3E6-1A35B5B53BED.htm

## Dissection

Ok, let's back up a second and reflect on what happened. There are a couple of questions left unanswered from running your first publish above.

1. Where did the publish go?
1. Why did it go there?
1. Where did the naming convention come from?
1. Why did we have to add the two attributes, `publishable` and `family`?
1. Why did we have to put `myCube` into a selection set?

From the top:

1. To your workspace.
1. Because the plugin `extract_as_ma` put it there.
1. From the plugin `validate_naming_convention`.
1. Because the plugin `select_object_set` was looking for it.
1. Because the plugin `select_object_set` was looking for this too.

Too direct? Yes, let's have a closer look at how all of this fits together.

### Where Did the Publish Go?

> To your workspace.

If you look within your project directory, you'll notice that you've now got a new folder called `published`.


    C:\Users\marcus\Documents\maya\projects\default\published


This is where Pyblish chose to store `MyCube` when you hit the Publish button. But how did it know to do that? And why did it put it in a subdirectory that looks like the current date and time, followed by a few other directories?

- ![](static/img/guide/octicon-file-directory.png) published
 - ![](static/img/guide/octicon-file-directory.png) 20140907-174550
   - ![](static/img/guide/octicon-file-directory.png) demo.model
     - ![](static/img/guide/octicon-file-directory.png) MyCube

And how did it know to produce 4 files? Why not 5, or 3? 

- ![](static/img/guide/octicon-file-directory.png) MyCube
 - ![](static/img/guide/octicon-file.png) MyCube.ma
 - ![](static/img/guide/octicon-file.png) MyCube.mb
 - ![](static/img/guide/octicon-file.png) MyCube.obj
 - ![](static/img/guide/octicon-file.png) MyCube.mtl

Well, the answer lies in the plugins.

#### How It Works

If you haven't already done so, now would be an excellent time to read [How It Works](#how-it-works). It'll provide you with an overview of how Pyblish processes your publishes. Once you're ready, come back here and we'll continue.

- [How It Works](#how-it-works)

### 5 Minutes Later

> Ok, so a selection plugin *selects* the cube?

Yes. It knows to do this because of how it is implemented.

It looks for nodes of type `objectSet` in your scene; specifically, nodes with the two attributes we added - `publishable` and `family`.

If you were to remove any of these two, the selector would go blind.

> Can I add anything to the `objectSet`?

Yes you can! That is the whole idea - you add what you intend on sharing with others. This way, you can separate the part of your scene that is sharable from the part that is not.

> What about the two attributes. What are they?

That's a good question. The `publishable` is merely an attribute to help the selector distinguish the nodes you are interested in publishing from those you are not. It's a way for the node to say "Me! Me! Me!" when you've got three identical nodes in your scene.

Remember when Neo took the red pill and they were able to locate him amongst a field of pods identical to his own?

`family` is where things start getting interesting. The family is a critical element of Pyblish. It's a way of saying "*this* instance belongs to *this* group of plugins". If you look at the selection set in your scene from your Attribute Editor, under "Extra Attributes", you'll see that the family attribute has the value "demo.model".


    print cmds.getAttr('MyCube.family')


> "demo.model"?

Yes, this is a way for the instance to say "I'd like all plugins compatible with `demo.model` to process me". Each plugin is associated with at least one (1) family. In effect, the instance is processed by a number of plugins compatible with this family.


    # A plugin may support multiple families, but
    # an instance may only support one.
     _______________        _______________
    |               |      |               |
    | Instance      |      | Plugin        |
    |               |      |               |
    |    demo.model o----->o demo.model    |
    |               |      o demo.anim     |
    |               |      o demo.rig      |
    |_______________|      |_______________|


> I'm confused..

Don't worry, this will make more sense once we get a little bit further in learning about Pyblish. All you need to remember from this is that each plugin carries a list of supported families and that all instances carries exactly one (1) family that may or may not match any of the available plugins.

### Why Did the Publish Go There?

> Because the plugin `extract_as_ma` put it there.

Well, if you remember from the [**How It Works**](#how-it-works), once selection and validation was complete, extraction took over. One of the extractors - specifically, one called `extract_as_ma` - is responsible for putting the files where they ended up.

Remember, the primary responsibility of an extractor is *getting data out of an application*. It doesn't have much concern for exactly where the data ends up, as that is not within its responsibilities. Instead, this responsibility is delegated to conformers.

> Why couldn't the extractor just put the files where I want them right away?

They most certainly could, this is merely a guideline. The separation is made due to cases where you have one or more things happening to content once it exits an application.

1. Data is moved to one location
1. Data is archived in another location
1. The event is logger with a task tracking solution

For example, ask yourself these questions.

- What about when the network is down and it can't move the files to where they belong? 
- What about when the internet is down and the event can't be logged?
- Should this stop the application from exporting the data?

These are concerns well suited for conformers.

### Where Did the Naming Convention Come From?
-
> From the plugin `validate_naming_convention`.

By now, you can probably answer the remaining questions yourself. But there is one important aspect I'd like to point out regarding the naming convention plugin.

The reason this naming convention was applied to "myCube_GEO" was because we specified that this cube was of family "demo.model".

We associated this family with our cube and in effect said "associate this particular naming convention to this cube".

## Conclusion

Ok, time for a breather. 

We've covered a lot of ground here but if there is one thing I'd like you to take with you it is that the manner in which we just published your first instance is fully dictated by the plugins currently exposed to Pyblish by the time you initiate your publish and that these plugins are just demos.

Pyblish is a "eat your own dog-food" library in that anything it does it does in the same manner you would do it if you were the one implementing the behaviour. We think this is important and it keeps us honest and our implementations open for learning and modification.

You're probably very excited about writing your own plugins by now, so let's do that! If you've saved your work (you'll need it next), read on.





# Creating Your First Plugin

You're probably burning with the desire to re-define selection, validation, extraction and conform all in one go, but let's stick with those baby steps and implement just one plugin!

**Table of contents**

- [Our plugin, the historian](#our-plugin-the-historian)
- [A little strategy](#a-little-strategy)
- [A look at the interface](#a-look-at-the-interface)
- [Implementation](#implementation)
- [We are family](#we-are-family)
- [Adding host support](#adding-host-support)
- [Saving your work](#saving-your-work)
- [Running your plugin](#running-your-plugin)
- [Registering your plugin](#registering-your-plugin)
- [Trying that again](#trying-that-again)
- [An error we've been waiting for](#an-error-weve-been-waiting-for)
- [Conclusion](#conclusion)
- [Persistently registering plugins](#persistently-registering-plugin)
 - [Via the environment variable](#via-the-environment-variable)
 - [Via configuration](#via-configuration)

### Our Plugin, the Historian

We'll be continuing our journey from where the previous tutorial left off and validate our cube just a little bit more. This time, we'll make sure that it lives up to those quality standards and that it doesn't have any history left behind from modeling.

### A Little Strategy

Let's take a moment to think about how we want this to go down.

In a nutshell, we want a plugin to look at our cube and determine whether or not it has history attached. We can probably utilise the `maya.cmds` module, but which command specifically?

[`maya.cmds.listHistory()`][listhistory] looks good, let's try that.


    >>> history = cmds.listHistory('myCube_GEO')
    >>> print history
    [u'myCube_GEOShape', u'polyCube1']


Hmm, the command does indeed give us the history of our node, but it also returns a shape node. Looks like we'll also need to check for those before making our evaluation.


    >>> for node in history:
    ...    if cmds.nodeType(node) is not "mesh":
    ...        print "This node has history!"
    ...        break


That should do it. Now we have a way of looking at `myCube_GEO` and determine whether or not it has any history attached. We would like our validator to do the same and prevent users from publishing until the problem has been fixed.

[listhistory]: http://help.autodesk.com/cloudhelp/2015/ENU/Maya-Tech-Docs/CommandsPython/listHistory.html

### A Look At The Interface

Plugins are sub-classed from `Plugin` - a base-class located at `pyblish.api`. `Plugin` is further divided into four sub-classes; Selector, Validator, Extractor and Conform respectively.

To get started, let's create a new module and our own plugin subclass.


    # validate_history.py
    import pyblish.api

    class ValidateHistory(pyblish.api.Validator):
        pass


Each plugin carries two methods of interest to us - `process_context` and `process_instance` - processing the context and instance respectively.

As we are interested in processing our instance, which contains `myCube_GEO`, we'll choose an appropriate method to override.


    # validate_history.py
    import pyblish.api

    class ValidateHistory(pyblish.api.Validator):
        def process_instance(self, instance):
            pass


Now that we have access to our instance, let's take a moment to talk about what the instance is in terms of Python.

> Technically, Context and Instance are both sub-classes of the Python `list`. As lists, they can be treated as iterables; the context containing one or more instances and an instance containing one or more nodes in your scene.

> 
    for instance in context:
        for node in instance:
            print "{0} - {1} - {2}".format(context, instance, node)


### Implementation

Considering this, we may retrieve `myCube_GEO` by iterating over the `instance` argument of `process_instance()`, and this is where we'll finally apply our validation. Don't forget to import `maya.cmds`.



    # Content discarded for brevity
    ...
        def process_instance(self, instance):
            for node in instance:
                for history in cmds.listHistory(node):
                    if cmds.nodeType(history) != "mesh":
                        raise TypeError("%s has incoming history!" % node)


At the very end, you can see that we're raising an exception. This is a validator's way of saying that an instance has not passed validation. If a validator doesn't raise an exception, all is considered well and the instance is considered valid. 

The message within the exception is presented to the user, so it's important that it contains what went wrong and what the user can do to remedy the issue.

### We Are Family

Now there is just one thing remaining before this plugin is ready to go. We'll need to associate it with a family.

Remember from our last tutorial that we associated the family "demo.model" to our instance? Well, if we want our custom plugin to operate on this instance we'll need to make it compatible with this family.


    ...
    class ValidateHistory(pyblish.api.Validator):
        families = ['demo.model']
    ...


> A plugin can support multiple families. 

> This is useful in situations where you may have a more general plugin apply to many types of families. For example, you may want naming convention to apply to both models and rigs.

### Adding Host Support

It is possible for you to have plugins applicable with a variety of hosts, not only for Maya. Some may only be compatible with Nuke, others with Houdini.

To indicate which host a particular plugin is designed for, add a `hosts` attribute to your plugin.


    ...
    class ValidateHistory(pyblish.api.Validator):
        families = ['demo.model']
        hosts = ['maya']
    ...


The full implementation now looks like this:


    import pyblish.api
    from maya import cmds


    class ValidateHistory(pyblish.api.Validator):
        families = ['demo.model']
        hosts = ['maya']

        def process_instance(self, instance):
            for node in instance:
                for history in cmds.listHistory(node):
                    if cmds.nodeType(history) != "mesh":
                        raise TypeError("%s has incoming history!" % node)



### Running Your Plugin

Choose a directory to your liking and save your plugin as `validate_history.py`. 

The name is important. Any module starting with `validate_` is considered a validator-plugin. Just as those starting with `select_`, `extract_` and `conform_` are considered a selector-, extractor- and conform-plugin respectively.

> You can change the manner in which plugins are discovered via your user-configuration file. For more information, head on back up to [Configuring Pyblish](#configuring-pyblish).

For the sake of this tutorial, I'll assume you've saved your plugin here.


    c:\my_plugins\validate_history.py


### Saving Your Work

Open up you scene from the last tutorial and run the following.


    import pyblish.api
    import pyblish.main

    context = pyblish.api.Context()
    pyblish.main.select(context)


At this point, `myCube_GEO` has been selected and now resides within an instance within the context. Let's run it through validation and see what happens.


    pyblish.main.validate(context)


Because `myCube_GEO` has history, the `polyCube1` generator, your plugin should have triggered an exception, but didn't. 

Why is that?

### Registering Your Plugin

For Pyblish to pick up your brilliant plugin, we'll first need to tell it about where you put it. You can register a directory in which you keep custom plugins. 

> You could store it along with where the other plugins are at, in the Pyblish Python package. But by doing this you risk loosing your plugins when updating or un-installing Pyblish.

In our case, we wish to register:


    c:\my_plugins


We can do that by adding to following command:


    pyblish.api.register_plugin_path(r'c:\my_plugins')


### Trying That Again

Our full script now looks like this.


    import pyblish.api
    import pyblish.main

    pyblish.api.register_plugin_path(r'c:\my_plugins')

    context = pyblish.api.Context()
    pyblish.main.select(context)
    pyblish.main.validate(context)


By registering our path, we've made Pyblish aware of our custom plugin.

### An Error We've Been Waiting For

If everything went right, we've got our error.


    # Error: pyblish.api.Plugin : An exception occured during processing of instance [u'MyCube'] # 
    # Error: TypeError: file C:\Python27\Lib\site-packages\pyblish\main.py line 71: |myCube_GEO|myCube_GEOShape has incoming history! # 


You'll also see that if you try and publish, the validator will prevent you.

1. In your `File` menu
2. Click `Publish`

Or type the following:


    import pyblish.main
    pyblish.main.publish_all()


The user has now been alerted of the fact that his cube isn't living up to the requirements set forth by us. 

We can remedy this by deleting all history.

1. With `myCube_GEO` selected
1. In your `Edit` menu
1. Click `Delete by Type`
1. Click `History`

Or type the following:


    cmds.delete('myCube_GEO', constructionHistory=True)


### Conclusion

Now that `myCube_GEO` is up to par with our standards, we can publish it once more!

1. In your `File` menu
2. Click `Publish`

Or type the following:


    import pyblish.main
    pyblish.main.publish_all()


Thanks to your plugin, you can now rest assured that all content of this family in your library are completely free of any history. You can imagine how useful this becomes once your library starts growing. By making a few validators such as the one we just made, we can ensure that no content misbehaves and that all content remains familiar to those who use it. 

This is also an important step in automation within your pipeline. We'll talk more about automation in later tutorials, but for now, let's have a final look at the registration process and what your options are here.

### Persistently Registering Plugins

You may have noticed that adding your custom path from Python isn't always an option. A more fool-proof method may be to store it some place where it will always get picked up. For this, you have a couple of options.

#### Via the Environment Variable

At run-time, Pyblish will be looking within your environment for a variable called `PYBLISHPLUGINPATH`. Instead of registering a path via Python, you can add it to this comma-separated list of paths.

> WARNING: setx is modifying your environment, use with care.


    # On Windows
    $ setx PYBLISHPLUGINPATH %PYBLISHPLUGINPATH%;c:\my_plugins


For more help with modifying your environment, see [Adding a new environment variable][var]

A benefit of environment variables is that it can be added to your application-launch procedure. For example, whenever you launch Maya, your "boot-strapper" could append plugins relevant to that application (*and current project!*) prior to it being run.

A disadvantage however is that environment variables are local to your machine and may not always be the most maintainable solution.

[var]: https://github.com/abstractfactory/pyblish/wiki/Adding-an-environment-variable

#### Via Configuration

As an alternative, you can specify paths in your configuration file. We haven't yet spoken about configuration and I'll get back to you once we have, but by storing paths via a configuration file, you can make this file shared across workstations and in this way provide for a maintainable method of specifying paths for your organisation.

A disadvantage however is that it is global to all of your applications and can't get distinguished in the same way as environment variables can with each running process.





# Troubleshooting

> ImportError: Error: Couldn't find pyblish_maya on your PYTHONPATH

This may be due to the default Python `site-packages` directory not being available to Maya. This is where all packages installed in Python goes, including Pyblish. To remedy this, add this path to your PYTHONPATH.


    # On Windows, this path is typically located here:
    c:\Python27\Lib\site-packages


You can add the environment variable by first restarting your terminal *(this is important)* then typing this:


    # WARNING: This will modify your user environment variables
    $ setx PYTHONPATH %PYTHONPATH%;c:\Python27\Lib\site-packages


For more help with modifying your environment, see [here][var]

[var]: https://github.com/abstractfactory/pyblish/wiki/Adding-an-environment-variable


> I'm still having trouble.

Add a comment below, or [email us][email] and we'll get back to you asap!

[email]: mailto:marcus@abstractfactory.io




# FAQ

> Is this similar to project X?

By project X, you might be referring to other pipeline-related projects such as Shotgun, FTrack, 5th Kind, Tactic or even the newly announced Redcurrant. Pyblish wouldn't dream of such great endeavours and instead focuses on a very minimal mission of quality assuring outgoing data from digital content creation software. Other projects are better suited at organising and event-handling.

> I still have questions

Add a comment below, or [email us][email] and we'll get back to you asap!

[email]: mailto:marcus@abstractfactory.io
[Abstract Factory]: http://abstractfactory.io

</pb-markdown>
</section>